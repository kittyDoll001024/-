[TOC]

# 微信小程序

**Appid：wxc6dedd0ce4c809c6**

### 小程序注册

**1.使用浏览器打开 https://mp.weixin.qq.com/ 网址**

![image-20220321103627158](https://s2.loli.net/2022/12/09/PxUS46T23FVdZqX.png)

**2.注册账号类型**

![image-20220321103722703](https://s2.loli.net/2022/12/09/cR8E9wWojPJivsX.png)

**3.填写账号信息**

![image-20220321103951065](https://s2.loli.net/2022/12/09/Yfw8FB6LvTrliCZ.png)

**4.邮箱激活**

![image-20220321104206124](https://s2.loli.net/2022/12/09/Tl4kbc8m7foeUOt.png)

**5.点击链接激活账号**

![image-20220321104248620](https://s2.loli.net/2022/12/09/JzO9tm1pN5ugiRo.png)

**6.主体类型**

![image-20220321104318785](https://s2.loli.net/2022/12/09/iUgruhqGbCF6I1J.png)

**7.主体信息登记**

![image-20220321104658967](https://s2.loli.net/2022/12/09/dABcbJ3rjVuhKpz.png)

**8.获取小程序 AppID**

![image-20220321105137118](https://s2.loli.net/2022/12/09/CDNTQqEr8PenyVM.png)

### 小程序安装

**下载地址**

https://developers.weixin.qq.com/miniprogram/dev/devtools/stable.html

![image-20220321110617244](https://s2.loli.net/2022/12/09/sXaZ1imNQCPjGRp.png)

### 创建小程序

**1.创建项目**

![image-20220321111550796](https://s2.loli.net/2022/12/09/l2WnZB41AOSaurI.png)

**2.填写项目信息**

![image-20220321111758777](https://s2.loli.net/2022/12/09/PIQn2BgNLw8hVdJ.png)

**3.创建项目完成**

![image-20220321112147200](https://s2.loli.net/2022/12/09/i4Ly6rzlDNqK5au.png)

**4.各项功能**

![image-20220321143720784](https://s2.loli.net/2022/12/09/yZIBhvGPnfLkuKb.png)

### 小程序项目结构

###### 1. 基本结构组成

![image-20220321145810165](https://s2.loli.net/2022/12/09/B7FJ4rziNLV8Ix9.png)

| 1. pages 用来存放所有小程序的页面                            |
| :----------------------------------------------------------- |
| **2. utils 用来存放工具性质的模块(格式化时间的自定义模块)**  |
| **3. app.js 小程序项目的入口文件**                           |
| **4. app.json 小程序项目的全局配置文件**                     |
| **5. app.wxss 小程序的全局样式文件**                         |
| **6. project.config.json 项目的配置文件**                    |
| **7. sitemap.json 用来配置小程序及其页面是否允许被微信索引** |

###### 2. 页面组成部分

**小程序官方建议把所有小程序的页面，都存放在 pages 目录中，以单独的文件夹存在**

| ① .js 文件（页面的脚本文件，存放页面的数据、事件处理函数等） |
| ------------------------------------------------------------ |
| **② .json 文件（当前页面的配置文件，配置窗口的外观、表现等)** |
| **③ .wxml 文件（页面的模板结构文件）**                       |
| **④ .wxss 文件 (当前页面的样式表文件)**                      |

###### 3. JSON 配置文件的作用

**JSON 是一种数据格式，在实际开发中，JSON 总是以配置文件的形式出现。小程序项目中也不例外：通过不同 的 .json 配置文件，可以对小程序项目进行不同级别的配置。**

| ① 项目根目录中的 app.json 配置文件                |
| ------------------------------------------------- |
| **② 项目根目录中的 project.config.json 配置文件** |
| **③ 项目根目录中的 sitemap.json 配置文件**        |
| **④ 每个页面文件夹中的 .json 配置文件**           |

###### 4. app.json 文件

**app.json 是当前小程序的全局配置，包括了小程序的所有页面路径、窗口外观、界面表现、底部 tab**

| ① pages：用来记录当前小程序所有页面的路径                    |
| ------------------------------------------------------------ |
| **② window：全局定义小程序所有页面的背景色、文字颜色等**     |
| **2.1 navigationBarBackgroundColor：导航栏背景颜色**         |
| **2.2 navigationBarTitleText：导航栏文字**                   |
| **2.3 navigationBarTextStyle：导航栏文字颜色(只能是 white, black)** |
| **2.4 backgroundTextStyle：导航栏下拉刷新图标的颜色**        |
| **2.5 enablePullDownRefresh：是否打开下拉刷新功能(默认为 false)** |
| **③ style：全局定义小程序组件所使用的样式版本(v2 最新版本)** |
| **④ sitemapLocation：用来指明 sitemap.json 的位置**          |

######  5. project.config.json 文件

**project.config.json 是项目配置文件，用来记录我们对小程序开发工具所做的个性化配置**

| 1. setting 中保存了编译相关的配置      |
| -------------------------------------- |
| **2. projectname 中保存的是项目名称**  |
| **3. appid 中保存的是小程序的账号 ID** |

###### 6. sitemap.json 文件

**微信现已开放小程序内搜索，效果类似于 PC 网页的 SEO。sitemap.json 文件用来配置小程序页面是否允许 微信索引。**

**当开发者允许微信索引时，微信会通过爬虫的形式，为小程序的页面内容建立索引。当用户的搜索关键字和页 面的索引匹配成功的时候，小程序的页面将可能展示在搜索结果中。**

![image-20220321153013053](https://s2.loli.net/2022/12/09/EbB4pYVu1meLkfJ.png)

**注意：sitemap 的索引提示是默认开启的，如需要关闭 sitemap 的索引提示，可在小程序项目配置文件 project.config.json 的 setting 中配置字段 checkSiteMap 为 false**

######  7. 页面的 .json 配置文件

**小程序中的每一个页面，可以使用 .json 文件来对本页面的窗口外观进行配置，页面中的配置项会覆盖 app.json 的 window 中相同的配置项。**

![image-20220321153151581](https://s2.loli.net/2022/12/09/MIicZaFrVe1Pyxm.png)

###### 8. 新建小程序页面

**只需要在 app.json -> pages 中新增页面的存放路径，小程序开发者工具即可帮我们自动创建对应的页面文件**

![image-20220321153326351](https://s2.loli.net/2022/12/09/lHKFMDAQYSE5PNO.png)![image-20220321153346992](https://s2.loli.net/2022/12/09/myLZJRCD75qTvNw.png)

###### 9. 修改项目首页

**只需要调整 app.json -> pages 数组中页面路径的前后顺序，即可修改项目的首页。小程序会把排在第一位的页 面，当作项目首页进行渲染**

### 小程序代码构成 

#### WXML

###### 1. 什么是 WXML

-  WXML（WeiXin Markup Language）是小程序框架设计的一套标签语言，用来构建小程序页面的结构，其作 用类似于网页开发中的 HTML。

###### 2. WXML 和 HTML 的区别

- ① 标签名称不同
  - HTML （div, span, img, a）
  - WXML（view, text, image, navigator）
- ② 属性节点不同
  - ``<a href="#">超链接</a>``
  - ``<navigator url="/pages/home/home"></navigator>``

- ③ 提供了类似于 Vue 中的模板语法
  - 数据绑定 
  -  列表渲染 
  -  条件渲染

#### WXSS

###### 1. 什么是 WXSS

- WXSS (WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式，类似于网页开发中的 CSS。

###### 2. WXSS 和 CSS 的区别

- ① 新增了 rpx 尺寸单位
  - CSS 中需要手动进行像素单位换算，例如 rem
  - WXSS 在底层支持新的尺寸单位 rpx，在不同大小的屏幕上小程序会自动进行换算
  - rpx：属于自适应单位(随着屏幕大小变化)
  - rpx：通常我们在屏幕宽度为 375 的一个大小进行调式，在 375 宽度下一个px单位，是两个rpx(方便换算单位)
- ② 提供了全局的样式和局部样式
  - 项目根目录中的 app.wxss 会作用于所有小程序页面
  - 局部页面的 .wxss 样式仅对当前页面生效
- ③ WXSS 仅支持部分 CSS 选择器
  - .class 和 #id 
  -  element 
  -  并集选择器、后代选择器 
  -  ::after 和 ::before 等伪类选择器

#### JS 逻辑交互

###### 1. 小程序中的 .js 文件

- 一个项目仅仅提供界面展示是不够的，在小程序中，我们通过 .js 文件来处理用户的操作。例如：响应用户的 点击、获取用户的位置等等。

###### 2. 小程序中 .js 文件的分类

**小程序中的 JS 文件分为三大类，分别是：**

- ① app.js 
  -  是整个小程序项目的入口文件，通过调用 App() 函数来启动整个小程序
-  ② 页面的 .js 文件  
  - 是页面的入口文件，通过调用 Page() 函数来创建并运行页面
-  ③ 普通的 .js 文件 
  -  是普通的功能模块文件，用来封装公共的函数或属性供页面使用

### 小程序的宿主环境

#### 宿主环境简介

###### 1. 什么是宿主环境

- 宿主环境（host environment）指的是程序运行所必须的依赖环境。例如： Android 系统和 iOS 系统是两个不同的宿主环境。安卓版的微信 App 是不能在 iOS 环境下运行的，所以， Android 是安卓软件的宿主环境，脱离了宿主环境的软件是没有任何意义的！

![image-20220321155841560](https://s2.loli.net/2022/12/09/HDh29QOYaIMx47F.png)![image-20220321155852819](https://s2.loli.net/2022/12/09/Fgb5HNhBWLIA7lt.png)

###### 2. 小程序的宿主环境

![image-20220321155941360](https://s2.loli.net/2022/12/09/EMqT4aXQ18NkvWO.png)![image-20220321155950585](https://s2.loli.net/2022/12/09/uGsWFi9tm1UlvLj.png)

###### 3. 小程序宿主环境包含的内容

- ① 通信模型 
- ② 运行机制 
- ③ 组件 
- ④ API

#### 通信模型

###### 1. 通信的主体

**小程序中通信的主体是渲染层和逻辑层**

- ① WXML 模板和 WXSS 样式工作在渲染层 
- ② JS 脚本工作在逻辑层

![image-20220322081432275](https://s2.loli.net/2022/12/09/6JB4uQczwSKxblF.png)

###### 2. 小程序的通信模型

**小程序中的通信模型分为两部分**

- ① 渲染层和逻辑层之间的通信 
  -  由微信客户端进行转发 
- ② 逻辑层和第三方服务器之间的通信 
  -  由微信客户端进行转发

![image-20220322081656893](https://s2.loli.net/2022/12/09/lDiB5dyWXnU3AQ6.png)

#### 运行机制

###### 1. 小程序启动的过程

- ① 把小程序的代码包下载到本地 
- ② 解析 app.json 全局配置文件
-  ③ 执行 app.js 小程序入口文件，调用 App() 创建小程序实例 
- ④ 渲染小程序首页 
- ⑤ 小程序启动完成

###### 6. 页面渲染的过程

- ① 加载解析页面的 .json 配置文件 
- ② 加载页面的 .wxml 模板和 .wxss 样式 
- ③ 执行页面的 .js 文件，调用 Page() 创建页面实例 
- ④ 页面渲染完成

#### 组件的使用

###### 1. 小程序中组件的分类

**小程序中的组件也是由宿主环境提供的，开发者可以基于组件快速搭建出漂亮的页面结构。官方把小程序的组 件分为了 9 大类**

- ① 视图容器 
- ② 基础内容
-  ③ 表单组件 
- ④ 导航组件 
- ⑤ 媒体组件 
- ⑥ map 地图组件
-  ⑦ canvas 画布组件 
- ⑧ 开放能力 
- ⑨ 无障碍访问

###### 2. 常用的视图容器类组件

- ① view 
  - 普通视图区域 
  - 类似于 HTML 中的 div，是一个块级元素 
  - 常用来实现页面的布局效果 
- ② scroll-view  
  - 可滚动的视图区域 
  - 常用来实现滚动列表效果 
- ③ swiper 和 swiper-item 
  - 轮播图容器组件 和 轮播图 item 组件

###### 3. view 组件的基本使用

| hover-class                | string      | none      | 否     | 指定按下去的样式类。当 `hover-class="none"` 时，没有点击态效果 (在wxss 中绑定样式) |
| :------------------------- | :---------- | :-------- | :----- | :----------------------------------------------------------- |
| **hover-stop-propagation** | **boolean** | **false** | **否** | **指定是否阻止本节点的祖先节点出现点击态 (冒泡事件)**        |
| **hover-start-time**       | **number**  | **50**    | **否** | **按住后多久出现点击态，单位毫秒**                           |
| **hover-stay-time**        | **number**  | **400**   | **否** | **手指松开后点击态保留时间，单位毫秒**                       |

###### 4. scroll-view 组件的基本使用

**可滚动视图区域。使用竖向滚动时，需要给[scroll-view](https://developers.weixin.qq.com/miniprogram/dev/component/scroll-view.html)一个固定高度，通过 WXSS 设置 height。组件属性的长度单位默认为px，[2.4.0](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html)起支持传入单位(rpx/px)。**

| scroll-x     | boolean     | false     | 否     | 允许横向滚动     |
| ------------ | ----------- | --------- | ------ | ---------------- |
| **scroll-y** | **boolean** | **false** | **否** | **允许纵向滚动** |

###### 5. swiper 和 swiper-item 组件的基本使用

| indicator-dots             | boolean     | false                 | 否     | 是否显示面板指示点       |
| -------------------------- | ----------- | --------------------- | ------ | ------------------------ |
| **indicator-color**        | **color**   | **rgba(0, 0, 0, .3)** | **否** | **指示点颜色**           |
| **indicator-active-color** | **color**   | **#000000**           | **否** | **当前选中的指示点颜色** |
| **autoplay**               | **boolean** | **false**             | **否** | **是否自动切换**         |
| **interval**               | **number**  | **5000**              | **否** | **自动切换时间间隔**     |
| **duration**               | **number**  | **500**               | **否** | **滑动动画时长**         |
| **circular**               | **boolean** | **false**             | **否** | **是否采用衔接滑动**     |

###### 6. text 的基本使用

- 文本组件 
-  类似于 HTML 中的 span 标签，是一个行内元素
- text 标签只能嵌套 text 标签

| selectable      | boolean     | false     | 否     | 文本是否可选 (已废弃)                                   |
| --------------- | ----------- | --------- | ------ | ------------------------------------------------------- |
| **user-select** | **boolean** | **false** | **否** | **文本是否可选，该属性会使文本节点显示为 inline-block** |
| **decode**      | **boolean** | **false** | **否** | **是否解码**                                            |

###### **7. rich-text 的基本使用**

- 富文本组件 
- 支持把 HTML 字符串渲染为 WXML 结构

| nodes | array/string | []   | 否   | 节点列表/HTML String |
| ----- | ------------ | ---- | ---- | -------------------- |

###### 8. button 的基本使用

- 按钮组件 
- 功能比 HTML 中的 button 按钮丰富 
- 通过 open-type 属性可以调用微信提供的各种功能（客服、转发、获取用户授权、获取用户信息等）

| size                   | string          | default(mini 小尺寸)                     | 否     | 按钮的大小                                                   |
| ---------------------- | --------------- | ---------------------------------------- | ------ | ------------------------------------------------------------ |
| **type**               | **string**      | **default(primary、 warn)**              | **否** | **按钮的样式类型**                                           |
| **plain**              | **boolean**     | **false**                                | **否** | **按钮是否镂空，背景色透明**                                 |
| **disabled**           | **boolean**     | **false**                                | **否** | **是否禁用**                                                 |
| **loading**            | **boolean**     | **false**                                | **否** | **名称前是否带 loading 图标**                                |
| **open-type**          | **string**      |                                          | **否** | **微信开放能力**                                             |
|                        |                 | **contact**                              |        | **打开客服会话，如果用户在会话中点击消息卡片后返回小程序，可以从 bindcontact 回调中获得具体信息，[具体说明](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/customer-message/customer-message.html) （*小程序插件中不能使用*）** |
|                        |                 | **share**                                |        | **触发用户转发，使用前建议先阅读[使用指引](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/share.html#使用指引)** |
|                        |                 | **getPhoneNumber**                       |        | **获取用户手机号，可以从bindgetphonenumber回调中获取到用户信息，[具体说明](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/getPhoneNumber.html) （*小程序插件中不能使用*）** |
|                        |                 | **getUserInfo(bindtap: getUserProfile)** |        | **获取用户信息，可以从bindgetuserinfo回调中获取到用户信息 （*小程序插件中不能使用*）** |
|                        |                 | **launchApp**                            |        | **打开APP，可以通过app-parameter属性设定向APP传的参数[具体说明](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/launchApp.html)** |
|                        |                 | **openSetting**                          |        | **打开授权设置页**                                           |
|                        |                 | **feedback**                             |        | **打开“意见反馈”页面，用户可提交反馈内容并上传[日志](https://developers.weixin.qq.com/miniprogram/dev/api/base/debug/wx.getLogManager.html)，开发者可以登录[小程序管理后台](https://mp.weixin.qq.com/)后进入左侧菜单“客服反馈”页面获取到反馈内容** |
|                        |                 | **chooseAvatar**                         |        | **获取用户头像，可以从bindchooseavatar回调中获取到头像信息** |
| **bindgetuserinfo**    | **eventhandle** |                                          | **否** | **用户点击该按钮时，会返回获取到的用户信息，回调的detail数据与[wx.getUserInfo](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/user-info/wx.getUserInfo.html)返回的一致，open-type="getUserInfo"时有效** |
| **bindgetphonenumber** | **eventhandle** |                                          | **否** | **获取用户手机号回调，open-type=getPhoneNumber时有效**       |
| **bindchooseavatar**   | **eventhandle** |                                          | **否** | **获取用户头像回调，open-type=chooseAvatar时有效**           |

###### 9. image 的基本使用

- 图片组件 
- image 组件默认宽度约 300px、高度约 240p

| **src**       | **string**  |                                                    | **否** | **图片资源地址**                                             |
| ------------- | ----------- | -------------------------------------------------- | ------ | ------------------------------------------------------------ |
| **webp**      | **boolean** | **false**                                          | **否** | **默认不解析 webP 格式，只支持网络资源**                     |
| **lazy-load** | **boolean** | **false**                                          | **否** | **图片懒加载，在即将进入一定范围（上下三屏）时才开始加载**   |
| **mode**      | **string**  | **scaleToFill**                                    | **否** | **图片裁剪、缩放的模式**                                     |
|               |             | **scaleToFill**                                    |        | **缩放模式，不保持纵横比缩放图片，使图片的宽高完全拉伸至填满 image 元素** |
|               |             | **aspectFit**                                      |        | **缩放模式，保持纵横比缩放图片，使图片的长边能完全显示出来。也就是说，可以完整地将图片显示出来。** |
|               |             | **aspectFill**                                     |        | **缩放模式，保持纵横比缩放图片，只保证图片的短边能完全显示出来。也就是说，图片通常只在水平或垂直方向是完整的，另一个方向将会发生截取。** |
|               |             | **widthFix**                                       |        | **缩放模式，宽度不变，高度自动变化，保持原图宽高比不变**     |
|               |             | **heightFix**                                      |        | **缩放模式，高度不变，宽度自动变化，保持原图宽高比不变**     |
|               |             | **top、bottom、center、left、right**               |        | **裁剪模式，不缩放图片，只显示图片所指区域**                 |
|               |             | **top left、top right、bottom left、bottom right** |        | **裁剪模式，不缩放图片，只显示图片所指区域**                 |

###### 10. navigator 的基本使用

- 页面导航组件 
-  类似于 HTML 中的 a 链接

| target        | string     | self             | 否     | 在哪个目标上发生跳转，默认当前小程序                         |
| ------------- | ---------- | ---------------- | ------ | ------------------------------------------------------------ |
|               |            | **self**         |        | **当前小程序**                                               |
|               |            | **miniProgram**  |        | **其它小程序**                                               |
| **url**       | **string** |                  | **否** | **当前小程序内的跳转链接**                                   |
| **open-type** | **string** | **navigate**     | **否** | **跳转方式**                                                 |
|               |            | **redirect**     |        | **关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面。** |
|               |            | **switchTab**    |        | **跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面**         |
|               |            | **reLaunch**     |        | **关闭所有页面，打开到应用内的某个页面**                     |
|               |            | **navigateBack** |        | **关闭当前页面，返回上一页面或多级页面。可通过 [getCurrentPages](https://developers.weixin.qq.com/miniprogram/dev/reference/api/getCurrentPages.html) 获取当前的页面栈，决定需要返回几层** |
|               |            | **exit**         |        | **退出小程序，`target="miniProgram"`时生效**                 |

###### 11. 小程序 API 的 3 大分类

- ① 事件监听 API
  - 特点：以 on 开头，用来监听某些事件的触发 
  - 举例：wx.onWindowResize(function callback) 监听窗口尺寸变化的事件
- ② 同步 API
  - 特点1：以 Sync 结尾的 API 都是同步 API 
  - 特点2：同步 API 的执行结果，可以通过函数返回值直接获取，如果执行出错会抛出异常
  - 举例：wx.setStorageSync('key', 'value') 向本地存储中写入内容
- ③ 异步 API
  - 特点：类似于 jQuery 中的 $.ajax(options) 函数，需要通过 success、fail、complete 接收调用的结果 
  - 举例：wx.request() 发起网络数据请求，通过 success 回调函数接收数据

### 小程序模板与配置

#### 模板语法-数据绑定

###### 1. 数据绑定的基本原则

- ① 在 data 中定义数据 
- ② 在 WXML 中使用数据

###### 2. 在 data 中定义页面的数据

**在页面对应的 .js 文件中，把数据定义到 data 对象中即可：**

````javascript
Page({
	data: {
		message: 数据
	}
})
````

###### 3. Mustache 语法的格式

**把data中的数据绑定到页面中渲染，使用 Mustache 语法（双大括号）将变量包起来**

````html
<view>{{ 绑定的数据名称 }}</view>
````

###### 4. Mustache 语法的应用场景

- 绑定内容
- 绑定属性 
- 运算（三元运算、算术运算等)

#### 模板语法-事件绑定

###### 1. 小程序中常用的事件

| 类型       | 绑定方式                       | 事件描述                                          |
| ---------- | ------------------------------ | ------------------------------------------------- |
| **tap**    | **bindtop 或 bind: tap**       | **手指触摸后马上离开，类似于 HTML 中 click 事件** |
| **input**  | **bindinput 或 bind: input**   | **文本框的输入事件**                              |
| **change** | **bindchange 或 bind: change** | **状态改变时触发**                                |

###### 2. 事件对象的属性列表

**当事件回调触发的时候，会收到一个事件对象 event**

| 属性               | 类型        | 说明                                             |
| ------------------ | ----------- | ------------------------------------------------ |
| **type**           | **String**  | **事件类型**                                     |
| **timeStamp**      | **Integer** | **页面打开到触发事件所经过的毫秒数**             |
| **target***        | **Object**  | **触发事件的组件的一些属性值集合***              |
| **currentTarget**  | **Object**  | **当前组件的一些属性值集合**                     |
| **detail***        | **Object**  | **额外的信息***                                  |
| **touches**        | **Array**   | **触摸事件，当前停留在屏幕中的触摸点信息的数组** |
| **changedTouches** | **Array**   | **触摸事件，当前变化的触摸点信息的数组**         |

###### 3. target 和 currentTarget 的区别

**target 是触发该事件的源头组件，而 currenttarget 则是当前事件所绑定的组件**

![image-20220326143532745](https://s2.loli.net/2022/12/09/QnxYgm5aO7yevi1.png)

点击内部的按钮时，点击事件以冒泡的方式向外扩散，也会触发到外层的 view 的 tap 事件处理函数

- **e.target 表示着触发事件的源头 (e.target 是内部的按钮组件)**
- **e.currentTarget 表示着当前正在触发事件的组件 (e.currentTarget 是当前的 view 组件)**

###### 4. bindtap 的语法格式

**在小程序中，是通过 tap 事件来响应用户的触摸行为(点击)**

- 通过 bindtap 给组件绑定 tap 事件

  - ````html
    <button bindtap="事件名">按钮</button>

- 在页面的 js 文件中定义对应的事件处理函数，事件参数通过 event (简写为: e) 来接收

  - ````javascript
    Page({
    	事件名(e) {
    		console.log(e)
    	}
    })

###### 5. 在事件处理函数中为 data 中的数据赋值

**通过 setData({ }) 方法，可以给页面 data 中的数据重新赋值**

**想要获取到 data 中的数据在方法中使用，通过 this.data.数据名**

```javascript
Page({
	data: {
		count: 0
	},
	事件名() {
		this.setData({
		 // 具体的代码操作
			count: this.data.count += 1
		})
	}
})
```

###### 6. 事件传参

**小程序中的事件传参比较特殊，不能在绑定事件的同时为事件处理函数传递参数** 

例：

````html
<button bindtap="事件名(参数)">事件传参</button>

<button bindtap="btnHandler(123)">事件传参</button>
````

**因为小程序会把 bindtap 的属性值，统一当作事件名称来处理，相当于要调用一个名称为 btnHandler(123)  的事件处理函数**

- 

**可以为组件提供 data-* 自定义属性传参，其中 * 代表的是参数的名字**

````html
<button bindtap="事件名" data-参数名="{{ 参数 }}"></button>

<button bindtap="btnHandler" data-info="{{ 2 }}"></button>
````

- info 会被解析为参数的名字  
- 数值 2 会被解析为参数的值

- 

**在事件处理函数中，通过 event.target.dataset.参数名 即可获取到具体参数的值 (event 简写为 e)**

````javascript
事件名(e) {
	// 获取参数
	e.target.dataset.参数名
}
````

###### 7. input 事件

**通过 input 事件响应文本框输入事件**

1.  为文本框绑定输入事件

````html
<input type="text" bindinput="事件名" />
````

2.  事件处理函数

````javascript
事件名(e) {
	// 获取文本框最新内容
	e.detail.value
}
````

###### 9. 文本框和 data 之间的数据同步

````javascript
<input type="text" bindinput="事件名" value="{{ 数据名 }}" />

Page({
	data: {
	  // 定义数据
		message: "啦啦啦"
	}
	// 处理函数
	事件名(e) {
		setData({
			message: e.detail.value
		})
	}
})
````

###### 10. 条件渲染 wx:if

在框架中，使用 `wx:if=""` 来判断是否需要渲染该代码块：

````html
<block wx:if="{{ flase }}"></block>
````

也可以用 `wx:elif` 和 `wx:else` 来添加一个 else 块：

````html
<block wx:if="{{ flase }}"></block>
<block wx:elif="{{ flase }}"></block>
<block wx:else></block>
````

**wx:if  与  hidden  之间的区别**

因为 `wx:if` 之中的模板也可能包含数据绑定，所以当 `wx:if` 的条件值切换时，框架有一个局部渲染的过程，因为它会确保条件块在切换时销毁或重新渲染。

同时 `wx:if` 也是**惰性的**，如果在初始渲染条件为 `false`，框架什么也不做，在条件第一次变成真的时候才开始局部渲染。

相比之下，`hidden` 就简单的多，组件始终会被渲染，只是简单的控制显示与隐藏。

一般来说，`wx:if` 有更高的切换消耗而 `hidden` 有更高的初始渲染消耗。因此，如果需要频繁切换的情景下，用 `hidden` 更好，如果在运行时条件不大可能改变则 `wx:if` 较好。

###### 11. hidden 属性

- 隐藏和显示 (与 vue 的 v-show 等同) 

````javascript
<block hidden="{{false}}"></block>
````

###### 12. block 标签

- block 标签 是一个包装元素，在页面上不做任何渲染
- 使用情况：一般用于逻辑层(例如：wx-if 或 wx-for)等

###### 13. 列表渲染 wx:for

**在组件上使用 `wx:for` 控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。**

**默认数组的当前项的下标变量名默认为 `index`，数组当前项的变量名默认为 `item`**

````javascript
<view wx:for="{{ 数组或对象 }}"
	  wx:for-item="item"
	  wx:for-index="index">
</view>
````

嵌套时使用

*****   在有多层 for 循环时 为防止 index 和 item 名称冲突可以自己自定义名称  **wx:for-item="自定义名称"**  **wx:for-index="自定义名称"**

**wx:key**

如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如 [input](https://developers.weixin.qq.com/miniprogram/dev/component/input.html) 中的输入内容，[switch](https://developers.weixin.qq.com/miniprogram/dev/component/switch.html) 的选中状态），需要使用 `wx:key` 来指定列表中项目的唯一的标识符。

`wx:key` 的值以两种形式提供

- 1. 字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。
- 2.  for 循环在绑定 key 值时当我们没有 id 或者 index 时  可以使用它本身的一个保留关键字 *this 代表在 for 循环中  的 item 本身，这种表示需要 item 本身是一个唯一的字符串  或者数字

**没有 wx:key 会造成 (当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。) **

**注意事项：**

- 当 `wx:for` 的值为字符串时，会将字符串解析成字符串数组
- 花括号和引号之间如果有空格，将最终被解析成为字符串

#### WXSS 模板样式

###### 1. 什么是 WXSS

WXSS (WeiXin Style Sheets)是一套样式语言，用于美化 WXML 的组件样式，类似于网页开发中的 CSS。

###### 2. WXSS 和 CSS 的关系

WXSS 具有 CSS 大部分特性，同时，WXSS 还对 CSS 进行了扩充以及修改，以适应微信小程序的开发。

与 CSS 相比，WXSS 扩展的特性有：

- rpx 尺寸单位 
-  @import 样式导入

##### 模板样式-rpx

###### 1. 什么是 rpx 尺寸单位 

rpx（responsive pixel）是微信小程序独有的，用来解决屏适配的尺寸单位。

###### 2. rpx 的实现原理

rpx 的实现原理非常简单：鉴于不同设备屏幕的大小不同，为了实现屏幕的自动适配，rpx 把所有设备的屏幕， 在宽度上等分为 750 份（即：当前屏幕的总宽度为 750rpx）

- 在较小的设备上，1rpx 所代表的宽度较小
- 在较大的设备上，1rpx 所代表的宽度较大

**小程序在不同设备上运行的时候，会自动把 rpx 的样式单位换算成对应的像素单位来渲染，从而实现屏幕适配**

###### 3. rpx 与 px 之间的单位换算*

在 iPhone6 上，屏幕宽度为375px，共有 750 个物理像素，等分为 750rpx。则： 

750rpx = 375px = 750 物理像素 

1rpx = 0.5px = 1物理像素

**官方建议：开发微信小程序时，设计师可以用 iPhone6 作为视觉稿的标准。 **

**开发举例：在 iPhone6 上如果要绘制宽100px，高20px的盒子，换算成rpx单位，宽高分别为 200rpx 和 40rpx**

##### 模板样式-样式导入

###### 1. 什么是样式导入 

使用 WXSS 提供的 @import 语法，可以导入外联的样式表

###### 2. @import 的语法格式

**@import 后跟需要导入的外联样式表的相对路径，用 ; 表示语句结束。示例如下：**

````javascript
// app.wxss
@import "路径";

// common.wxss
.user {
	样式
}
````

##### 模板样式 - 全局样式和局部样式

###### 1. 全局样式 

定义在 app.wxss 中的样式为全局样式，作用于每一个页面

###### 2. 局部样式 

在页面的 .wxss 文件中定义的样式为局部样式，只作用于当前页面

 **注意：**

**① 当局部样式和全局样式冲突时，根据就近原则，局部样式会覆盖全局样式** 

**② 当局部样式的权重大于或等于全局样式的权重时，才会覆盖全局的样式**

#### 全局配置

##### 全局配置

###### 1. 全局配置文件及常用的配置项

小程序根目录下的 app.json 文件是小程序的全局配置文件。常用的配置项如下：

- ① pages 
  - 记录当前小程序所有页面的存放路径 

- ② window 
  - 全局设置小程序窗口的外观 

- ③ tabBar 
  - 设置小程序底部的 tabBar 效果 

- ④ style 
  - 是否启用新版的组件样式

###### 2. 了解 window 节点常用的配置项

| 属性名                           | 类型         | 默认值      | 说明                                               |
| -------------------------------- | ------------ | ----------- | -------------------------------------------------- |
| **navigationBarTitleText**       | **String**   | **字符串**  | **导航栏标题文字内容**                             |
| **navigationBarBackgroundColor** | **HexColor** | **#000000** | **导航栏背景颜色，如 #000000**                     |
| **navigationBarTextStyle**       | **String**   | **white**   | **导航栏标题颜色，仅支持 black / white**           |
| **backgroundColor**              | **HexColor** | **#ffffff** | **窗口的背景色**                                   |
| **backgroundTextStyle**          | **String**   | **dark**    | **下拉 loading 的样式，仅支持 dark / light**       |
| **enablePullDownRefresh**        | **Boolean**  | **false**   | **是否全局开启下拉刷新**                           |
| **onReachBottomDistance**        | **Number**   | **50**      | **页面上拉触底事件触发时距页面底部距离，单位为px** |

###### 3. 全局开启下拉刷新功能

**概念：下拉刷新是移动端的专有名词，指的是通过手指在屏幕上的下拉滑动操作，从而重新加载页面数据的行为**

###### 4. 设置上拉触底的距离

**概念：上拉触底是移动端的专有名词，通过手指在屏幕上的上拉滑动操作，从而加载更多数据的行为**



##### 全局配置-tabbar

**在app.json 配置文件，和 pages、window 平级，新增 tabBar 节点**

###### 1. 什么是 tabBar

tabBar 是移动端应用常见的页面效果，用于实现多页面 的快速切换。小程序中通常将其分为：

- 底部 tabBar
- 顶部 tabBar

**注意：**

- **tabBar中只能配置最少 2 个、最多 5 个 tab 页签** 

- **当渲染顶部 tabBar 时，不显示 icon，只显示文本**

###### 2. tabBar 的组成部分

| 属性                | 类型         | 必填   | 默认值     | 描述                                                         |
| ------------------- | ------------ | ------ | ---------- | ------------------------------------------------------------ |
| **color**           | **HexColor** | **是** |            | **tab 上的文字默认颜色，仅支持十六进制颜色**                 |
| **selectedColor**   | **HexColor** | **是** |            | **tab 上的文字选中时的颜色，仅支持十六进制颜色**             |
| **backgroundColor** | **HexColor** | **是** |            | **tab 的背景色，仅支持十六进制颜色**                         |
| **borderStyle**     | **string**   | **否** | **black**  | **tabbar 上边框的颜色， 仅支持 `black` / `white`**           |
| **list**            | **Array**    | **是** |            | **tab 的列表，详见 `list` 属性说明，最少 2 个、最多 5 个 tab** |
| **position**        | **string**   | **否** | **bottom** | **tabBar 的位置，仅支持 `bottom` / `top`**                   |

其中 list 接受一个数组，**只能配置最少 2 个、最多 5 个 tab**。tab 按数组的顺序排序，每个项都是一个对象，其属性值如下：

| 属性             | 类型   | 必填 | 说明                                                         |
| ---------------- | ------ | ---- | ------------------------------------------------------------ |
| pagePath         | string | 是   | 页面路径，必须在 pages 中先定义                              |
| text             | string | 是   | tab 上按钮文字                                               |
| iconPath         | string | 否   | 图片路径，icon 大小限制为 40kb，建议尺寸为 81px * 81px，不支持网络图片。 **当 `position` 为 `top` 时，不显示 icon。** |
| selectedIconPath | string | 否   | 选中时的图片路径，icon 大小限制为 40kb，建议尺寸为 81px * 81px，不支持网络图片。 **当 `position` 为 `top` 时，不显示 icon。** |

##### 页面配置

###### 1. 页面配置和全局配置的关系

**app.json 中的部分配置，也支持对单个页面进行配置，可以在页面对应的 `.json` 文件来对本页面的表现进行配置。**

**页面中配置项在当前页面会覆盖 `app.json` 中相同的配置项**

###### 2. 页面配置中常用的配置项

| 属性                             | 类型         | 默认值       | 描述                                                         |
| -------------------------------- | ------------ | ------------ | ------------------------------------------------------------ |
| **navigationBarBackgroundColor** | **HexColor** | **#000000**  | **导航栏背景颜色，如 `#000000`**                             |
| **navigationBarTextStyle**       | **string**   | **white**    | **导航栏标题颜色，仅支持 `black` / `white`**                 |
| **navigationBarTitleText**       | **string**   |              | **导航栏标题文字内容**                                       |
| **navigationStyle**              | **string**   | **default**  | **导航栏样式，仅支持以下值： `default` 默认样式 `custom` 自定义导航栏，只保留右上角胶囊按钮。** |
| **backgroundColor**              | **HexColor** | **#ffffff**  | **窗口的背景色**                                             |
| **backgroundTextStyle**          | **string**   | **dark**     | **下拉 loading 的样式，仅支持 `dark` / `light`**             |
| **blePullDownRefresh**           | **boolean**  | **false**    | **是否开启当前页面下拉刷新。 详见 [Page.onPullDownRefresh](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onpulldownrefresh)** |
| **onReachBottomDistance**        | **number**   | **50**       | **页面上拉触底事件触发时距页面底部距离，单位为px。 详见 [Page.onReachBottom](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onreachbottom)** |
| **disableScroll**                | **boolean**  | **false**    | **设置为 `true` 则页面整体不能上下滚动。 只在页面配置中有效，无法在 `app.json` 中设置** |
| **singlePage**                   | **Object**   | **否**       | **单页模式相关配置**                                         |
| **restartStrategy**              | **string**   | **homePage** | **重新启动策略配置**                                         |
| **handleWebviewPreload**         | **string**   | **static**   | **控制[预加载下个页面的时机](https://developers.weixin.qq.com/miniprogram/dev/framework/performance/tips/runtime_nav.html#_2-4-控制预加载下个页面的时机)。支持 `static` / `manual` / `auto`** |

#### 网络数据请求

###### 1. 小程序中网络数据请求的限制

出于安全性方面的考虑，小程序官方对数据接口的请求做出两个限制

- ① 只能请求 HTTPS 类型的接口
- ② 必须将接口的域名添加到信任列表中

![image-20220405174823662](https://s2.loli.net/2022/12/09/lzAdje7KI5CxQSi.png)

###### 2. 配置 request 合法域名

![image-20220405190306645](C:\Users\27598\AppData\Roaming\Typora\typora-user-images\image-20220405190306645.png)

![image-20220405190357811](https://s2.loli.net/2022/12/09/1AqmLdZsgzTxlQp.png)

**注意事项：** 

**① 域名只支持 https 协议** 

**② 域名不能使用 IP 地址或 localhost** 

**③ 域名必须经过 ICP 备案** 

**④ 服务器域名一个月内最多可申请 5 次修改**

###### 3. 使用 wx.request 方法发起数据请求

**GET 请求**

````javascript
wx.request({
	url: "",
	mehtod: "GET",
	// 发送到服务器的数据
	data: {},
	success: (res => {})
})
````

**POST 请求**

````javascript
wx.request({
	url: "",
	method: "POST",
	data: {},
	success: (res => {})
})
````

###### 4. 在页面加载时请求数据

需要在页面的 onLoad 事件中调用获取数据的函数

````javascript
Page({
	onLoad() {
		this.函数名()
	}
})
````

###### 5. 跳过 request 合法域名检测

在仅提供了 http 协议的接口、暂时没有提供 https  协议的接口下临时开启「开发环境不校验请求域名、TLS 版本及 HTTPS 证书」

**注：跳过 request 合法域名校验的选项，仅限在开发与调试阶段使用！**

![image-20220406143549774](https://s2.loli.net/2022/12/09/7uaz5HjVZrwWonK.png)

###### 6. 关于在小程序数据请求跨域的问题

跨域问题只存在于基于浏览器的 Web 开发中。由于小程序的宿主环境不是浏览器，而是微信客户端，所以小 程序中不存在跨域的问题。

### 小程序视图与逻辑

#### 页面导航

###### 1. 在小程序中实现页面导航的两种方式

- ① 声明式导航
  - 在页面上通过点击 navigator 导航组件实现跳转
- ② 编程式导航
  - 调用小程序的导航 API ，实现页面的跳转

##### 页面导航 - 声明式导航

###### 1. 导航到 tabbar 页面

在使用 navigator 去跳转 tabbar 页面时，需要指定的有

- url  属性
- open-type 属性

````javascript
// 代码演示
<navigator url="路径" open-type="switchTab"></navigator>
````

###### 2. 导航到非 tabbar 页面

在使用 navigator 去跳转非 tabbar 页面时，需要指定的有

- url  属性
- open-type 属性 (在非 tabbar 页面时可以省略)

````javascript
// 代码演示
<navigator url="路径" open-type="navigate"></navigator>
````

###### 3. 后退导航

在使用 navigator 去后退到上一个页面或多个页面时，需要指定的有

- open-type 属性
- delta  属性  (当后退页数为 1 时可以省略)

````javascript
// 代码演示
<navigator open-type="navigateBack" delta="页数"></navigator>
````

##### 页面导航 - 编程式导航

###### 1. 导航到 tabbar 页面

````javascript
// 代码演示
// 点击跳转
<view bindtap="事件名"></view>

// .js 中
事件名() {
	wx.swichTab({
		url: "路径"
	})
}
````

###### 2. 导航到非 tabbar 页面

````javascript
// 代码演示
// 点击跳转
<view bindtap="事件名"></view>

// .js 中
事件名() {
	wx.navigateTo({
		url: "路径"
	})
}
````

###### 3. 后退导航

````javascript
// 代码演示
// 点击跳转
<view bindtap="事件名"></view>

// .js 中
事件名() {
	wx.navigateBack({
		// 在后退页数为 1 时 delta 可以不用写
		delta: 1
	})
}
````

##### 页面导航 - 导航传参

###### 1. 声明式导航传参

navigator 组件的 url 属性用来指定将要跳转到的页面的路径。同时，路径的后面还可以携带参数：

- 参数与路径之间使用 ? 分隔 

- 参数键与参数值用 = 相连 

- 不同参数用 & 分隔

````javascript
// 代码演示
<navigator url="路径?name='男'&age=20"></navigator>
````

###### 2. 编程式导航传参

````javascript
// 代码演示
<view bindtap="事件名"></view>

// .js 中
事件名() {
	wx.navigateTo({
		url: "路径?name='男'&age=20"
	})
}
````

###### 3. 接收导航参数

通过声明式或者是编程式导航传参所携带的参数，可以在我们的 onLoad 声明周期中直接获取到

````javascript
// onLOad 生命周期监听页面加载
onLoad(opions) {
	// 在这里就可以获取到我们传递过来的参数
	conolse.log(opions)
}
````

#### 页面事件

##### 页面事件 - 下拉刷新事件

###### 1. 启用下拉刷新

- 全局开启 (不建议)
  - 在 app.json 中的 window 里的 enablePullDownRefresh 设置为 true
- 局部开启
  - 在 相对应的文件中的 .json 中里的 enablePullDownRefresh 设置为 true

###### 2. 配置下拉刷新窗口的样式

在 app.json 中配置文件中来配置

- backgroundColor：  用来配置下拉刷新窗口的背景颜色，仅支持16 进制的颜色值
- backgroundTextStyle：  用来配置下拉刷新 loading 的样式，仅支持 dark 和 light

###### 3. 监听页面的下拉刷新事件

在相对应的文件中的 .js 文件中 通过 onPullDownRefresh() 函数即可监听当前页面的拉下刷新事件

###### 4. 关闭下拉刷新效果

当处理完下拉刷新后，下拉刷新的 loading 效果会一直显示，不会主动消失，所以需要手动隐藏下拉刷新的 loading 效果。此时，调用 wx.stopPullDownRefresh() 可以停止当前页面的下拉刷新。 

````javascript
// 代码演示(3、4)
onPullDownRefresh() {
	// 下拉刷新的事件
	
	// 关闭下来刷新效果
	wx.stopPullDownRefresh()
}
````

##### 页面事件 - 上拉触底事件

###### 1. 监听页面的上拉触底事件

在页面的 .js 文件中，通过 onReachBottom 函数即可监听当前页面的上拉触底事件

````javascript
onReachBottom() {
	// 上拉触底事件处理
}
````

###### 2. 配置上拉触底距离

上拉触底距离指的是触发上拉触底事件时，滚动条距离页面底部的距离。 可以在全局或页面的 .json 配置文件中，通过 onReachBottomDistance 属性来配置上拉触底的距离。 小程序默认的触底距离是 50px

###### 3. 添加 loadiing 提示效果

````javascript
// 添加 loading 
wx.showLoading({title: '加载中'})

// 移除 loading
 wx.hideLoading()
````

![image-20220406202730540](https://s2.loli.net/2022/12/09/ORB2da3Vf9Ugt1G.png)

#### 生命周期

###### 1. 什么是生命周期

生命周期是指一个对象从创建 -> 运行 -> 销毁的整个阶段，强调的是一个时间段。

###### 2. 生命周期的分类

在小程序中生命周期分为两类

- 应用生命周期
  - 小程序从启动 -> 运行 -> 销毁的过程
- 页面生命周期
  - 小程序中的没个页面的加载 -> 渲染 -> 销毁的过程

![image-20220407151746875](https://s2.loli.net/2022/12/09/BjRcmSEuwrnfzJY.png)

###### 3. 什么是生命周期

- 生命周期函数：是由小程序框架提供的内置函数，会伴随着生命周期，自动按次序执行。

- 生命周期函数的作用：允许程序员在特定的时间点，执行某些特定的操作。
- **注意：生命周期强调的是时间段，生命周期函数强调的是时间点**

###### 4. 应用的生命周期

应用的生命周期函数需要在 app.js 中声明

| 属性                                                         | 类型     | 说明                                           |
| ------------------------------------------------------------ | -------- | ---------------------------------------------- |
| [onLaunch](https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#onLaunch-Object-object) | function | 此函数，全局只触发一次，可以监听小程序初始化。 |
| [onShow](https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#onShow-Object-object) | function | 监听小程序启动或切前台。                       |
| [onHide](https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#onHide) | function | 监听小程序切后台。                             |
| [onError](https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#onError-String-error) | function | 错误监听函数。                                 |
| [onPageNotFound](https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#onPageNotFound-Object-object) | function | 页面不存在监听函数。                           |
| [onUnhandledRejection](https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#onUnhandledRejection-Object-object) | function | 未处理的 Promise 拒绝事件监听函数。            |
| [onThemeChange](https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#onThemeChange-Object-object) | function | 监听系统主题变化                               |

###### 5. 页面的生命周期

页面的生命周期函数需要在页面的 .js 中声明

| 属性              | 参数     | 说明                                               |
| ----------------- | -------- | -------------------------------------------------- |
| onLoad            | options  | 监听页面加载，一个页面只调用一次                   |
| onShow            | 无       | 监听页面显示                                       |
| onReady           | 无       | 监听页面初次渲染完成，一个页面只调用一次           |
| onHide            | 无       | 监听页面隐藏                                       |
| onUnload          | 无       | 监听页面卸载，一个页面只调用一次                   |
| **应用事件**      |          |                                                    |
| **属性**          | **类型** | **说明**                                           |
| onPullDownRefresh | Function | 页面相关事件处理函数——监听用户下拉动作             |
| onReachBottom     | Function | 页面上拉触底事件的处理函数                         |
| onShareAppMessage | Function | 用户点击右上角转发                                 |
| onPageScroll      | Function | 页面滚动触发事件的处理函数                         |
| onPageNotFound    |          | 当编译的页面没有找到，可以在这里设置跳转到其他页面 |

###### 6. 组件的生命周期

组件的生命周期，指的是组件自身的一些函数，这些函数在特殊的时间点或遇到一些特殊的框架事件时被自动触发。

其中，最重要的生命周期是 `created` `attached` `detached` ，包含一个组件实例生命流程的最主要时间点。

- 组件实例刚刚被创建好时， `created` 生命周期被触发。此时，组件数据 `this.data` 就是在 `Component` 构造器中定义的数据 `data` 。 **此时还不能调用 `setData` 。** 通常情况下，这个生命周期只应该用于给组件 `this` 添加一些自定义属性字段。
- 在组件完全初始化完毕、进入页面节点树后， `attached` 生命周期被触发。此时， `this.data` 已被初始化为组件的当前值。这个生命周期很有用，绝大多数初始化工作可以在这个时机进行。
- 在组件离开页面节点树后， `detached` 生命周期被触发。退出一个页面时，如果组件还在页面节点树中，则 `detached` 会被触发。

定义生命周期方法

生命周期方法可以直接定义在 `Component` 构造器的第一级参数中。

自小程序基础库版本 [2.2.3](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) 起，组件的的生命周期也可以在 `lifetimes` 字段内进行声明（这是推荐的方式，其优先级最高）。

````javascript
Component({
  lifetimes: {
    attached: function() {
      // 在组件实例进入页面节点树时执行
    },
    detached: function() {
      // 在组件实例被从页面节点树移除时执行
    },
  },
  // 以下是旧式的定义方式，可以保持对 <2.2.3 版本基础库的兼容
  attached: function() {
    // 在组件实例进入页面节点树时执行
  },
  detached: function() {
    // 在组件实例被从页面节点树移除时执行
  },
  // ...
})
````

**在 behaviors 中也可以编写生命周期方法，同时不会与其他 behaviors 中的同名生命周期相互覆盖。但要注意，如果一个组件多次直接或间接引用同一个 behavior ，这个 behavior 中的生命周期函数在一个执行时机内只会执行一次。**

| 生命周期     | 参数               | 描述                                         |
| ------------ | ------------------ | -------------------------------------------- |
| **created**  | **无**             | **在组件实例刚刚被创建时执行**               |
| **attached** | **无**             | **在组件实例进入页面节点树时执行**           |
| **ready**    | **无**             | **在组件在视图层布局完成后执行**             |
| **moved**    | **无**             | **在组件实例被移动到节点树另一个位置时执行** |
| **detached** | **无**             | **在组件实例被从页面节点树移除时执行**       |
| **error**    | **`Object Error`** | **每当组件方法抛出错误时执行**               |

**还有一些特殊的生命周期，它们并非与组件有很强的关联，但有时组件需要获知，以便组件内部处理。这样的生命周期称为“组件所在页面的生命周期”，在 `pageLifetimes` 定义段中定义。**

| 生命周期   | 参数              | 描述                             |
| ---------- | ----------------- | -------------------------------- |
| **show**   | **无**            | **组件所在的页面被展示时执行**   |
| **hide**   | **无**            | **组件所在的页面被隐藏时执行**   |
| **resize** | **`Object Size`** | **组件所在的页面尺寸变化时执行** |

- show：当页面再次被打开可以打开相应的计时器功能
- hide：比如页面中有计时器等功能页面退到后台运行时，就没有继续运行的必要，就可以在这里进行关闭操作
- resize：一般情况就是监听页面的横竖屏切换

````javascript
Component({
  pageLifetimes: {
    show: function() {
      // 页面被展示
    },
    hide: function() {
      // 页面被隐藏
    },
    resize: function(size) {
      // 页面尺寸变化
    }
  }
})
````

###### 7. 开启横竖屏切换

`"pageOrientation": "auto"`

- auto ：自动

- portrait : 默认（竖屏）

- landscape ： 横屏

**可以写在 app.json 文件的 window ， 或其他的 .json 文件中**

#### WXS脚本

##### 一、WXS 概述

###### 1. 什么是 wxs

WXS 是小程序独有的一套脚本语言，结合 WXML，可以构建出页面的结构

###### 2. wxs 的应用场景

wxml 中无法调用在页面的 .js 中定义的函数，但是，wxml 中可以调用 wxs 中定义的函数。

因此，小程序中 wxs 的典型应用场景就是“过滤器”

###### 3. wxs 和 JavaScript 的关系

**虽然 wxs 的语法类似于 JavaScript，但是 wxs 和 JavaScript 是完全不同的两种语言：**

-  ① **wxs 有自己的数据类型** 
  - number 数值类型、string 字符串类型、boolean 布尔类型、object 对象类型、 
  - function 函数类型、array 数组类型、 date 日期类型、 regexp 正则 
- ② **wxs 不支持类似于 ES6 及以上的语法形式** 
  - 不支持：let、const、解构赋值、展开运算符、箭头函数、对象属性简写、etc... 
  - 支持：var 定义变量、普通 function 函数等类似于 ES5 的语法 
- ③ **wxs 遵循 CommonJS 规范**
  - module 对象
  - require() 函数
  - module.exports 对象
-  ④ **wxs 的数据类型**
  -  number 数值
  -  string 字符串
  -  boolean 布尔值
  -  object 对象
  -  function 函数
  -  array 数组
  -  date 日期
  -  regexp 正则


##### 二、基础语法

###### 1. 内嵌 wxs 脚本

- wxs 代码可以编写在 wxml 文件中的  标签内，就像 Javascript 代码可以编写在 html 文件中的 
- wxml 文件中的每个  标签，必须提供 module 属性，用来指定当前 wxs 的模块名称，方便在 wxml 中访问模块中的成员

````javascript
// 代码演示
<view>{{ m1.toUpper(username) }}</view>

// 脚本
<wxs module="m1">
	module.exports.toUpper = function(str) {
		return str.toUpperCase()
	}
</wxs>
````

###### 2. 定义外联的 wxs 脚本

- wxs 代码还可以编写在以 .wxs 为后缀名的文件内，就像 javascript 代码可以编写在以 .js 为后缀名的文件中 一样

````javascript
// 代码演示
// tools.wxs 文件
function toLower(str) {
	return str.toLowerCase()
}

module.exports = {
	toLower: toLower
}
````

###### 3. 使用外联 wxs 脚本

在 wxml 中引入外联的 wxs 脚本时，必须为  标签添加 module 和 src 属性

- module 用来指定模块的名称
- src 用来指定要引入的脚本的路径，且必须是相对路径

````javascript
// 代码演示
<view>{{ m2.toLower(country) }}</view>

// 脚本
<wxs src="路径" module="m2"></wxs>
````

##### 三、WXS 脚本特点

###### 1. 不能作为组件的事件回调

- wxs 典型的应用场景就是“过滤器”，经常配合 Mustache 语法进行使用
- 在 wxs 中定义的函数不能作为组件的事件回调函数

###### 2. 隔离性

- ① wxs 不能调用 js 中定义的函数 

- ② wxs 不能调用小程序提供的 API

###### 3. 性能好

- 在 iOS 设备上，小程序内的 WXS 会比 JavaScript 代码快 2 ~ 20 倍
- 在 android 设备上，二者的运行效率无差异

### 小程序基础加强

#### 一、自定义组件

##### 自定义组件 - 组件的创建于引用

###### 1. 创建组件

- ① 在项目的根目录中，鼠标右键，创建 components -> test 文件夹 

- ② 在新建的 components -> test 文件夹上，鼠标右键，点击“新建 Component” 

- ③ 键入组件的名称之后回车，会自动生成组件对应的 4 个文件，后缀名分别为 .js，.json， .wxml 和 .wxss

**注意：为了保证目录结构的清晰，建议把不同的组件，存放到单独目录中**

###### 2. 组件的引用

组件的引用方式分为“局部引用”和“全局引用”

- 局部引用：组件只能在当前被引用的页面内使用
- 全局引用：组件可以在每个小程序页面中使用

###### 3. 引用、使用组件

在相对应的文件中 .json 文件去引用 (全局与局部用一样的方式引用)

![image-20220408083408826](https://s2.loli.net/2022/12/09/Krnot32evZ8xzjY.png)

使用组件

![image-20220408083612793](https://s2.loli.net/2022/12/09/wtpiEoA8DdjNMr2.png)

###### 4. 全局组件与局部组件的优劣

根据组件的使用频率和范围，来选择

- 在多个页面中要使用，建议全局
- 在特定的页面中使用，建议局部

###### 5. 组件和页面的区别

从表面来看，组件和页面都是由 .js、.json、.wxml 和 .wxss 这四个文件组成的。但是，组件和页面的 .js 与 .json 文件有明显的不同

- 组件的 .json 文件中需要声明 "component": true 属性
- 组件的 .js 文件中调用的是 Component() 函数
- 组件的事件处理函数需要定义到 methods 节点中

##### 自定义组件 - 样式

###### 1. 组件样式隔离

在默认情况下自定义组件只对当前的组件生效，不会影响到其他组件或页面，页面的样式也无法对组件生效

优势：

- 防止外界的样式影响组件内部的样式

- 防止组件的样式破坏外界的样式

###### 2. 组件样式的隔离注意点

- 全局样式对组件无效
- 只有 class 选择器又隔离效果
- id选择器，属性选择器，标签选择器不受样式隔离影响

**建议：在组件和引用组件的页面中建议使用 class 选择器，不要使用 id、属性、标签选择器**

###### 3. 修改组件的样式隔离选项

默认情况下，自定义组件的样式隔离特性能够防止组件内外样式互相干扰的问题。

但有时，我们希望在外界能 够控制组件内部的样式，此时，可以通过 styleIsolation 修改组件的样式隔离选项

````javascript
// 代码演示
Component({
	options: {
		stylelsolstion: "isolated"
	}
})
````

| 可选值       | 默认值 | 描述                                                         |
| ------------ | ------ | ------------------------------------------------------------ |
| isolated     | 是     | 启用样式隔离，在自定义组件内使用，使用 class 指定的样式不会相会影响 |
| apply-shared | 否     | 页面样式影响到自定义组件，但自定义组件样式不会影响页面       |
| shared       | 否     | 页面样式影响到组件，组件样式也影响到页面和其他设置了 apply-shared 或 shared 的组件 |

##### 自定义组件 - 数据、方法和属性

###### 1. data 数据

用于组件模板渲染的私有数据，要定义到 data 中

###### 2. methods 方法

事件处理函数和自定义方法要定义到 methods 中

###### 3. properties 属性

properties 是组件对外属性，用来接收外界传递到组件中的数据

###### 4. data 和 properties 的区别

properties 属性和 data 数据的用法相同，都是可读可写的

- data 更倾向于存储组件的私有数据
- properties 更倾向于外界传递到组件的数据

###### 5. 使用 this.setDate 修改 properties 

data 数据和 properties 属性在本质上没有任何区别，properties 的值也可以渲染页面

使用 this.setDate 为 properties 重新赋值

##### 自定义组件 - 数据监听器

###### 1. 什么是数据监听器

数据监听器用于监听和响应任何属性和数据字段的变化，从而执行它的操作

````javascript
// 代码演示
Component({
	observers: {
		'字段1，字段2': function(字段1的新值, 字段2的新值) {
		
		}
	}
})
````

###### 2. 监听对象属性的变化

数据监听器支持监听对象中单个或多个属性的变化

````javascript
// 代码演示
Component({
	observers: {
		'对象.属性1, 对象.属性2': function(属性1的新值, 属性2的新值) {
			// 触发此监听器的 3 中情况
			// [为属性1赋值] 使用 setData 设置 this.data.对象.属性1 时触发
			// [为属性2赋值] 使用 setData 设置 this.data.对象.属性2 时触发
			// [直接为对象赋值] 使用 setData 设置 this.data.对象 时触发
		}
	}
})
````

##### 自定义组件 - 纯数据字段

###### 1. 概念

纯数据字段是一些不用于界面渲染的 data 字段，可以用于提升页面更新性能

###### 2. 好处及在何处使用

有些情况下，某些 data 中的字段（包括 setData 设置的字段）既不会展示在界面上，也不会传递给其他组件，仅仅在当前组件内部使用

可以知道那个这样的数据字段为 ”纯数据字段“，它们将仅仅被记录在 this.data 中，而不参与任何界面渲染过程，这样有助于提升页面更新性能

指定 ”纯数据字段“ 的方法是在 Component 构造器的 options 定义段中指定 pureDataPattern 为一个正则表达式，字段符合这个正则表达式的字段将成为 ”纯数据字段“

````javascript
Component({
	options: {
		// 指定所有 _ 开头的数据字段为纯数据字段
		pureDataPattern: /^_/
	},
	data: {
		a: 0,   // 普通数据
		_b: 0   // 纯数据字段
	}
})
````

##### 自定义组件 - 插槽

在组件的 wxml 中可以包含 `slot` 节点，用于承载组件使用者提供的 wxml 结构。

默认情况下，一个组件的 wxml 中只能有一个 slot 。需要使用多 slot 时，可以在组件 js 中声明启用。

````javascript
Component({
	options: {
		// 在组件定义时的选项中启用多 slot 支持
		multipleSlots: true 
	}
})
````

在组件中使用多个 slot 用不同的 name 来区分

````javascript
<view>
	<slot name="名称1"></slot>
	<slot name="名称2"></slot>
</view>
````

使用时，用 `slot` 属性来将节点插入到不同的 slot 上。

````javascript
<view>
	<view slot="名称1"></view>
	<view slot="名称2"></view>
</view>
````

##### 自定义组件 - 父子组件之间的通信

###### 1. 父子组件之间通信的 3 种方式

- ①  属性绑定
  - 用于父组件向子组件的指定属性设置数据，仅能设置 JSON 兼容的数据
- ②  事件绑定
  - 用于子组件向父组件传递数据，可以传递任意数据
- ③  获取组件实例
  - ​	父组件还可以通过 this.selectComponent() 获取子组件实例对象
  - 这样就可以直接访问子组件的任意数据和方法

###### 2. 属性绑定（父传子）

1.  在父组件中一个自定义属性， 并把所需要的值通过 双大括号插值来传递
2.  在子组件中的 .js 文件里的一个 properties 对象中使用父组件传过来的值

````javascript
// 父组件
<Nav 属性名="{{ 传输值 }}"></Nav>

// 子组件
properties: {
	属性名: {
		type: 数据类型
		value: 默认值
	}
}
````

###### 3. 事件绑定（子传父）

1.  在父组件的 .js  中，定义一个函数，这个函数通过自定义事件的形式，传递给子组件
2. 在父组件的 wxml 中，通过自定义事件的形式，将步骤 1 中定义的函数引用，传递给子组件
3. 在子组件的 .js 中，通过调用 this.triggerEvent("自定义事件名", { 参数对象 })，将数据发送到父组件
4. 在父组件的 .js 中，通过 e.detail 获取到子组件传递过来的数据

- 在子组件中的事件中通过 `this.triggerEvent(事件名，所传数据)`
- 在父组件中用 `bind事件名`  来接收

````javascript
// 子组件
methods: {
	事件名(所传数据) {
		this.triggerEvent("事件名", 所传数据)
	}
}

// 父组件
<Nav bind:事件名=""/>
````

###### 4. 获取组件实例

在父组件里调用 this.selectComponent(”class选择器 或 id选择器“)，获取子组件的实例对象，来访问子组件的任意数据和方法

````javascript
// 代码演示
// 父组件中
事件处理函数() {
	var child = this.selectComponent("选择器")
	// 访问数据
	child.setDate
	// 访问方法，方法是写在原型上的(__proto__)
	child.方法名
}
````

##### 自定义组件 - behaviors

###### 1. 什么是 behaviors 

用于实现组件之间代码共享的特性，类似于 vue 中的 mixins[混入]

###### 2. behaviors 的工作方式

每个 behaviors 可以包含一组属性、数据、生命周期和方法。

组件引用时，它的属性、数据、方法会被合并到组件中

每个组件可以引用多个 behaviors ，behaviors 也可以引用其他 behaviors 

###### 3. 创建 behaviors 

在根目录下创建 behaviors 文件夹，文件夹中创建 behaviors.js 文件

````javascript
// 调用 Behavior() 方法，创建实例对象
// 并使用 module.exports 将 behavior 实例对象共享出去
module.exports = Behavior({
	// 属性节点
	proprtties: {},
	// 私有数据节点
	data: {},
	// 事件处理函数和自定义方法节点
	methods: {}
})
````

###### 4. 导入并使用 behaviors 

在组件中，使用 require() 方法导入需要的 behavior ，挂载后即可访问 behavior 中的数据和方法

````javascript
// 使用 require() 导入需要的自定义 behavior 模块
const myBehavior = require(路径)
Component({
	// 将导入的 behavior 实例对象，挂载到 behaviors 数组节点中
	behaviors: [myBehavior]
})
````

###### 5. behavior 中所有可用的节点

| 可用的节点 | 类型         | 是否必填 | 描述                |
| ---------- | ------------ | -------- | ------------------- |
| properties | Object Map   | 否       | 同组件的属性        |
| data       | Object       | 否       | 同组件的数据        |
| methods    | Object       | 否       | 同自定义组件的方法  |
| behaviors  | String Array | 否       | 引入其它的 behavior |
| created    | Function     | 否       | 生命周期函数        |
| attached   | Function     | 否       | 生命周期函数        |
| ready      | Function     | 否       | 生命周期函数        |
| moved      | Function     | 否       | 生命周期函数        |
| detached   | Function     | 否       | 生命周期函数        |

###### 6. 同名字段的覆盖和组合规则

- 属性(properties)或方法(methods)的同名：
  - 组件本身有这个属性或方法，组件的属性或方法会覆盖 `behavior` 中的同名属性或方法；
  - 组件本身无这个属性或方法，在组件的 `behaviors` 字段中定义靠后的 `behavior` 的属性或方法会覆盖靠前的同名属性或方法
  - 在2的基础上，若存在嵌套引用 `behavior` 的情况，则规则为：`引用者 behavior` 覆盖 `被引用的 behavior` 中的同名属性或方法
- 同名的数据字段 (data)：
  - 同名的数据字段都是对象类型，会进行对象合并
  - 其余情况会进行数据覆盖，覆盖规则为： `引用者 behavior` > `被引用的 behavior` 、 `靠后的 behavior` > `靠前的 behavior`。（优先级高的覆盖优先级低的，最大的为优先级最高）
- 生命周期函数不会相互覆盖，而是在对应触发时机被逐个调用：
  - 不同的生命周期函数之间，遵循组件生命周期函数的执行顺序
  - 同种生命周期函数，遵循如下规则：
    - `behavior` 优先于组件执行；
    - `被引用的 behavior` 优先于 `引用者 behavior` 执行；
    - `靠前的 behavior` 优先于 `靠后的 behavior` 执行；
  - 同一个 `behavior` 被一个组件多次引用，它定义的生命周期函数只会被执行一次、

##### 自定义 tabBar

###### 1. 配置信息

在 app.json 文件中的 tabBar 中指定 custom 字段

````javascript
"tabBar": {
  "custom": true,
  "list": []
}
````

**注：为了保证低版本兼容以及区分哪些页面是 tab 页，tabBar 的相关配置项需完整声明，但这些字段不会作用于自定义 tabBar 的渲染**

###### 2. 创建 tabBar 相关文件

在根目录下创建 custom-tab-bar 文件并创建 Component

###### 3. 编写  tabBar 

推荐使用 Vant 组件库

#### **二、使用 npm 包**

##### 小程序对 npm 的支持与限制

- 不支持依赖于 Node.js 内置的包
- 不支持依赖于 浏览器内置对象的包
- 不支持依赖于 C++ 插件的包

##### 使用 npm 包 - Vant Weapp

###### 1. 安装 Vant 组件库

- 先查看是否有包管理配置文件，如果没有则初始化项目
  - `npm init -y`

- 通过 npm 安装 (建议指定版本号 @1.3.3 为版本号)
  - `npm i @vant/weapp@1.3.3 -S --production`
- 构建 npm 包
  - 在老版本中需要自己构建 npm 包
  - ![image-20220410133642724](https://s2.loli.net/2022/12/09/YUe4ysSWkfiZxDC.png)
  - 在新版本中则取消了在本地设置去配置 npm 模块（直接构建就好）
  - ![image-20220410133808755](https://s2.loli.net/2022/12/09/CrlX6IhSeGsOn7N.png)
- 修改 app.json 文件
  - 把样式版本去掉（防止样式冲突）
  - ![image-20220410134023515](https://s2.loli.net/2022/12/09/MzYciCVExNmdkl8.png)

###### 2. 使用 Vant 组件

在对应的 .json 文件中的 usingComponents 节点引入需要的组件，根据组件的使用频繁度来决定是否声明在全局的 .json 文件中

````javascript
"usingComponents": {
	"van-button": "@vant/weapp/button/index"
}

// 使用
<van-button></van-button>
````

具体使用什么组件可以在 Vant-weapp文档中去查找

###### 3. 定制全局主题样式

普通定制

````javascript
page {
	--color-test: red
}
````

Vant 样式定制（具体样式可参考文档）

文档地址：https://github.com/youzan/vant-weapp/blob/dev/packages/common/style/var.less

````javascript
page {
	--button-default-border-color: #border-color;
	--button-primary-color: white;
}
````

##### 使用 npm 包 - API Promise化

###### 1. 基于回调函数的异步 API 的缺点

官方提供的异步 API 都是基于回调函数实现的

容易造成回调地狱的问题，代码的可读性、维护性差

###### 2. 什么是 API promise 化

是指通过额外的配置，将官方提供的、基于回调函数的异步 API ，升级改造为基于 Promise 的异步 API，从而提高代码的可读性、维护性，避免了回调地狱的问题。

###### 3. 实现 API Promise 化

实现 API Promise 化主要依赖于 miniprogram-api-promise 这个第三方的 npm 包

- 安装

  - `npm install --save miniprogram-api-promise@1.0.4`
  - 在每次安装任意的 npm 包后都需要重构一下 npm 防止出现错误（在重新构建时最好先把之间的包手动删除，再去构建）

- 使用

  - ````javascript
    // 在 app.js 文件，只需要调用一次 PromisifyAll() 方法
    import { promisifyAll } from 'miniprogram-api-promise'
    
    const wxp = wx.p = {}
    // promisifyAll all wx's api
    promisifyAll(wx, wxp)

###### 4. 调用 Promise 化之后的异步 API

````javascript
async getRequest() {
	const res = await wx.p.request({
		url: "网址",
		method: "请求类型",
		data: {}
	})
}

// 在不使用 async、await 修饰会返回一个 promise
// 要请求到数据需要 async / await 来修饰
````

#### 三、全局数据共享

##### 全局数据共享

###### 1. 什么时全局数据共享

全局数据共享(状态管理)是为了解决组件之间的数据共享问题（类似于vuex）

###### 2. 全局数据共享方案

使用 mobx-miniprogram 配合 mobx-miniprogram-bindings 实现全局数据共享

- mobx-miniprogram 用来创建 Store 实例对象
- mobx-miniprogram-bindings 用来把 Store 的数据共享数据或方法，绑定到组件或页面中使用

##### 全局数据共享 - Mobx

###### 1. 安装 Mobx 包

`npm install --save mobx-miniprogram@4.13.2 mobx-miniprogram-bindings@1.2.1`

###### 2. 创建 Mobx 的 Store 实例

````javascript
import { observable, action } from "mobx-miniprogram"

export const store = observable({
	// 数据状态
	numA: 1,
	// 计算属性
	get sum() {
		return this.numA + this.numB
	}
	// 逻辑处理
	// action 方法，用来修改 store 中的数据
	// function 函数不能使用箭头函数
	updataNumA: actions(function(step) {
		this.numA += step
	})
})
````

###### 3. 将 Store 中的成员绑定到页面

````javascript
import { createStoreBindngs } from "mobx-miniprogram-bindings"  // 便于将 store 中的方法绑定到页面中
import { store } from '存放 store 的路径'  // 引入 store 中的数据状态及方法

Page({
	// 生命周期函数--监听页面加载
	onLoad: function() {
		this.storeBindings = createStoreBindings(this, {
			store,
			fields: ['numA', 'numB', 'sum'],
			actions: ['updateNumA']
		})
	},
	// 生命周期函数--监听页面卸载
	onUnload: function() {
		this,storeBindings.destroyStoreBindings()
	}
})

````

- this：代表当前页面的实例
- store：代表数据源
- fields：代表需要把那些字段绑定到当前的页面上进行使用
- actions：代表需要把那些方法绑定到当前页面上来进行使用
- this.storeBindings：是 createStoreBindings 的一个返回值
  - 另外它还有对页面的一个清理的作用
  - 需要在 onUnload 生命周期中进行调用一个 destroyStoreBindings 函数来进行页面清理

###### 4. 在页面上使用 Store 的成员

可以通过双大括号插值的方法来展示

在 .js 中 可以 this.方法名来获取到

###### 5. 将 Store 中的成员绑定到组件中

组件中的使用方法与页面上的一样

````javascript
import { storeBindingsBehavior } from 'mobx-miniprogram-bindings'
import { store } from '存放 store 的路径'
Component({
	// 通过 storeBindingsBehavior 来实现自动绑定
	behaviors: [storeBindingsBehavior]
	storeBindings: {
		// 指定要绑定的 Store
		store,
		// 指定要绑定的字段数据
		fields: {
			// 前面的是在页面中使用的名称，后面是 store 中的
 			numA: 'numA',
      numB: 'numB',
      sum: 'sum'
		},
		// 指定要绑定的方法
		actions: {
			updateNumA: 'updateNumA'
		}
	}
})
````

#### 四、分包

##### 分包 - 基础概念

###### 1. 什么是分包

分包指的是把一个完整的小程序项目，按照需求划分为不同的子包，在构建时打包成不同的分包，用户在使用 时按需进行加载

###### 2. 分包的好处

- 可以优化小程序首次启动的下载时间
- 在多团队共同开发时可以更好的解耦协作

###### 3. 分包前项目的构成

分包前，小程序项目中所有的页面和资源都被打包到了一起，导致整个项目体积过大，影响小程序首次启动的 下载时间

###### 4. 分包后项目的构成

- 主包：一般只包含项目的启动页面或 TabBar 页面、以及所有分包都需要用到的一些公共资源
- 分包：只包含和当前分包有关的页面和私有资源

###### 5. 分包的加载规则

① 在小程序启动时，默认会下载主包并启动主包内页面

- tabBar 页面需要放到主包中

② 当用户进入分包内某个页面时，客户端会把对应分包下载下来，下载完成后再进行展示

- 非 tabBar 页面可以按照功能的不同，划分为不同的分包之后，进行按需下载

###### 6. 分包的体积限制

- 整个小程序所有分包大小不超过 16M（主包 + 所有分包）
- 单个分包/主包大小不能超过 2M

##### 分包 - 使用分包

###### 1. 配置方法

![image-20220410202007946](https://s2.loli.net/2022/12/09/sjA3Gczd9RPO5Z6.png)

![image-20220410200805780](https://s2.loli.net/2022/12/09/qlUtMNZaXTBfRAS.png)

######  2. 打包原则

- 小程序会按 subpackages 的配置进行分包，subpackages 之外的目录将被打包到主包中
- 主包也可以有自己的 pages、
- tabBar 页面必须在主包内
- 分包之间不能互相嵌套

###### 3. 引用原则

- 主包无法引用分包内的私有资源
- 分包之间不能相互引用私有资源
- 分包可以引用主包内的公共资源

##### 分包 - 独立分包

###### 1. 什么是独立分包

独立分包本质上也是分包，只不过它比较特殊，可以独立于主包和其他分包而单独运行。

###### 2. 独立分包和普通分包的区别

最主要的区别：是否依赖于主包才能运行

- 普通分包必须依赖于主包才能运行
- 独立分包可以在不下载主包的情况下，独立运行

###### 3. 独立分包的应用场景

将某些具有一定功能独立性的页面配置到独立分包中

- 当小程序从普通的分包页面启动时，需要首先下载主包
- 而独立分包不依赖主包即可运行，可以很大程度上提升分包页面的启动速度

**注意：一个小程序中可以有多个独立分包**

###### 4. 独立分包的配置方法

![image-20220410203030466](https://s2.loli.net/2022/12/09/rnV9XZQhzJcOkKj.png)

###### 5. 引用原则

独立分包和普通分包以及主包之间，是相互隔绝的，不能相互引用彼此的资源

- 主包无法引用独立分包内的私有资源
- 独立分包之间，不能相互引用私有资源
- 独立分包和普通分包之间，不能相互引用私有资源
- **特别注意：独立分包中不能引用主包内的公共资源**

##### 分包 - 分包预下载

###### 1.  什么是分包预下载

分包预下载指的是：在进入小程序的某个页面时，由框架自动预下载可能需要的分包，从而提升进入后续分包 页面时的启动速度

###### 2. 配置分包的预下载

在 app.json 中，使用 preloadRule 节点定义分包的预下载 规则

![image-20220411081722461](https://s2.loli.net/2022/12/09/XW7R84JDukthAZx.png)

###### 3.  分包预下载的限制

同一个分包中的页面享有共同的预下载大小限额 2M

![image-20220411082028501](https://s2.loli.net/2022/12/09/qfVe9rnGil6ayLM.png)

### 小程序常用方法

#### wx.switchTab

**跳转到 tabBar 页面，并关闭其他非 tabBar 页面**

wx.switchTab(object, object)

使用 Promise 调用

````javascript
// 代码演示
"list": [{
      "pagePath": "/pages/index/index",
      "text": "首页",
  }, {
      "pagePath": "/pages/news/news",
      "text": "消息",
  }]
  
wx.switchTab({
	url: "跳转文件地址"
})
````
